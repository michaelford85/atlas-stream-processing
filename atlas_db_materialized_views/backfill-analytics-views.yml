---
- name: Backfill materialized views for sample_analytics
  hosts: localhost
  gather_facts: false

  pre_tasks:
    - name: Check if local processor details file exists
      ansible.builtin.stat:
        path: "./vars/processor_details_local.yml"
      register: local_vars_file

    - name: Include local processor details if it exists
      ansible.builtin.include_vars:
        file: "./vars/processor_details_local.yml"
      when: local_vars_file.stat.exists

    - name: Include default processor details if no local override exists
      ansible.builtin.include_vars:
        file: "./vars/processor_details.yml"
      when: not local_vars_file.stat.exists

    - name: Set mongodb_uri from vars
      ansible.builtin.set_fact:
        mongodb_uri: "mongodb+srv://{{ atlas_cluster_user }}:{{ atlas_cluster_password }}@{{ atlas_cluster_uri }}/?retryWrites=true&w=majority"

    - name: Sanity check MONGODB_URI
      ansible.builtin.fail:
        msg: "Set MONGODB_URI in your environment (mongodb+srv://... or mongodb://...)."
      when: mongodb_uri | length == 0

  tasks:

    - name: Backfill customers_ref (from sample_analytics.customers)
      ansible.builtin.shell: |
        mongosh "{{ mongodb_uri }}" --quiet <<'JS'
        use {{ src_db }};
        db.customers.aggregate([
          {
            $project: {
              "_id": 1,
              "username": 1,
              "name": 1,
              "email": 1,
              "tier_and_details": "$tier_and_details",
              "account_ids": "$accounts"
            }
          },
          {
            $merge: {
              into: { db: "{{ sink_db }}", coll: "customers_ref" },
              on: ["_id"],
              whenMatched: "replace",
              whenNotMatched: "insert"
            }
          }
        ], { allowDiskUse: true });
        JS
      args:
        executable: /bin/bash

    - name: Backfill accounts_ref (from sample_analytics.accounts)
      ansible.builtin.shell: |
        mongosh "{{ mongodb_uri }}" --quiet <<'JS'
        use {{ src_db }};
        db.accounts.aggregate([
          { $project: { 
            _id: 1,
            account_id: 1,
            limit: 1, 
            products: 1 
            } 
          },
          {
            $merge: {
              into: { db: "{{ sink_db }}", coll: "accounts_ref" },
              on: "_id",
              whenMatched: "replace",
              whenNotMatched: "insert"
            }
          }
        ], { allowDiskUse: true });
        JS
      args:
        executable: /bin/bash

    - name: Backfill transactions_flat (unwind transactions array)
      ansible.builtin.shell: |
        mongosh "{{ mongodb_uri }}" --quiet <<'JS'
        use {{ src_db }};
        db.transactions.aggregate([
          { $unwind: "$transactions" },
          {
            $project: {
              _id: 0,
              account_id: 1,
              date: "$transactions.date",
              symbol: "$transactions.symbol",
              amount: "$transactions.amount",
              price: "$transactions.price",
              transaction_code: "$transactions.transaction_code"
            }
          },
          {
            $merge: {
              into: { db: "{{ sink_db }}", coll: "transactions_flat" },
              on: ["account_id", "date", "symbol", "amount", "price"],
              whenMatched: "replace",
              whenNotMatched: "insert"
            }
          }
        ], { allowDiskUse: true });
        JS
      args:
        executable: /bin/bash


    - name: Backfill transactions_enriched (join to customers_ref to add customer/tier)
      ansible.builtin.shell: |
        mongosh "{{ mongodb_uri }}" --quiet <<'JS'
        use {{ sink_db }};
        db.transactions_flat.aggregate([
          {
            $lookup: {
              from: "customers_ref",
              let: { acc: "$account_id" },
              pipeline: [
                { $match: { $expr: { $in: ["$$acc", "$account_ids"] } } },
                { $project: { _id: 1, username: 1, name: 1, email: 1, tier_and_details: 1 } }
              ],
              as: "cust"
            }
          },
          { $set: { 
              customer: { 
                $first: "$cust" 
              }, 
              tier_and_details: { 
                $getField: {
                  input: { $first: "$cust.tier_and_details" },
                  field: { $toString: "$account_id" }
                }
              }
            }
          },
          { $unset: "cust" },

          {
            $lookup: {
              from: "accounts_ref",
              localField: "account_id",
              foreignField: "account_id",
              as: "acct"
            }
          },
          {
            $set: {
              products: { $first: "$acct.products" },
              account_limit: { $first: "$acct.limit" } // optional
            }
          },
          { $unset: "acct" },
          { $project: {
              _id: 0,
              account_id: 1,
              date: 1,
              symbol: 1,
              amount: 1,
              price: 1,
              transaction_code: 1,
              customer_name: "$customer.username",
              customer_username: "$customer.username",
              customer_email: "$customer.email",
              customer_tier_and_details: "$customer.tier_and_details",
              products: 1,
              account_limit: 1
            }
          },
          {
            $merge: {
              into: { db: "{{ sink_db }}", coll: "transactions_enriched" },
              on: ["account_id", "date"],
              whenMatched: "replace",
              whenNotMatched: "insert"
            }
          }
        ], { allowDiskUse: true });
        JS
      args:
        executable: /bin/bash
